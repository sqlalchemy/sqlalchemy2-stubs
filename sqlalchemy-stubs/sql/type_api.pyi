from _typeshed import SupportsLessThan
from typing import Any
from typing import Callable
from typing import Generic
from typing import Mapping
from typing import Optional
from typing import Text
from typing import Tuple
from typing import Type
from typing import TypeVar
from typing import Union
from typing_extensions import Protocol

from . import operators as operators
from .base import SchemaEventTarget as SchemaEventTarget
from .visitors import Traversible as Traversible
from .visitors import TraversibleType as TraversibleType
from .. import exc as exc
from .. import util as util

BOOLEANTYPE: Any
INTEGERTYPE: Any
NULLTYPE: Any
STRINGTYPE: Any
MATCHTYPE: Any
INDEXABLE: Any
TABLEVALUE: Any

_T = TypeVar("_T")
_U = TypeVar("_U")

_TE = TypeVar('_TE', bound=TypeEngine[Any])
_NFE = TypeVar('_NFE', bound=NativeForEmulated)
_TD = TypeVar('_TD', bound=TypeDecorator[Any])
_VT = TypeVar('_VT', bound=Variant[Any])

_SortKeyFunction = Callable[[Any], SupportsLessThan]

class TypeEngine(Traversible, Generic[_T]):
    class Comparator(operators.ColumnOperators):
        default_comparator: Any = ...
        def __clause_element__(self): ...
        expr: Any = ...
        type: Any = ...
        def __init__(self, expr: Any) -> None: ...
        def operate(self, op: Any, *other: Any, **kwargs: Any): ...
        def reverse_operate(self, op: Any, other: Any, **kwargs: Any): ...
        def __reduce__(self): ...
    hashable: bool = ...
    comparator_factory: Type[Any] = ...
    sort_key_function: Optional[_SortKeyFunction] = ...
    should_evaluate_none: bool = ...
    def evaluates_none(self: _TE) -> _TE: ...
    def copy(self: _TE, **kw: Any) -> _TE: ...
    def compare_against_backend(
        self, dialect: Any, conn_type: Any
    ) -> Any: ...
    def copy_value(self, value: _T) -> _T: ...
    def literal_processor(self, dialect: Any) -> Optional[Callable[[Optional[_T]], str]]: ...
    def bind_processor(self, dialect: Any) -> Optional[Callable[[Optional[_T]], Optional[Any]]]: ...
    def result_processor(self, dialect: Any, coltype: Any) -> Optional[Callable[[Optional[Any]], Optional[_T]]]: ...
    def column_expression(self, colexpr: Any) -> Any: ...
    def bind_expression(self, bindvalue: Any) -> Any: ...
    def compare_values(self, x: Any, y: Any) -> bool: ...
    def get_dbapi_type(self, dbapi: Any) -> Any: ...
    @property
    def python_type(self) -> Type[_T]: ...
    def with_variant(self, type_: Type[TypeEngine[_U]], dialect_name: str) -> Variant[_U]: ...
    def as_generic(self, allow_nulltype: bool = ...) -> TypeEngine[Any]: ...
    def dialect_impl(self, dialect: Any) -> Type[Any]: ...
    def adapt(self, __cls: Type[_U], **kw: Any) -> _U: ...
    def coerce_compared_value(self, op: Any, value: Any) -> TypeEngine[Any]: ...
    def compile(self, dialect: Optional[Any] = ...) -> Any: ...

class VisitableCheckKWArg(util.EnsureKWArgType, TraversibleType): ...

class UserDefinedType:
    __visit_name__: str = ...
    ensure_kwarg: str = ...
    def coerce_compared_value(self, op: Any, value: Any) -> Any: ...

class Emulated:
    def adapt_to_emulated(self, impltype: Any, **kw: Any) -> Any: ...
    def adapt(self, __impltype: Any, **kw: Any) -> Any: ...

class NativeForEmulated:
    @classmethod
    def adapt_native_to_emulated(cls, impl: Any, **kw: Any) -> Any: ...
    @classmethod
    def adapt_emulated_to_native(cls: Type[_NFE], impl: Any, **kw: Any) -> _NFE: ...

class TypeDecorator(SchemaEventTarget, TypeEngine[_T]):
    __visit_name__: str = ...
    impl: Any = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    coerce_to_is_types: Tuple[Type[Any], ...] = ...
    class Comparator(TypeEngine.Comparator):
        def operate(self, op: Any, *other: Any, **kwargs: Any): ...
        def reverse_operate(self, op: Any, other: Any, **kwargs: Any): ...
    @property
    def comparator_factory(self) -> Type[Any]: ...  # type: ignore[override]
    def type_engine(self, dialect: Any) -> TypeEngine[Any]: ...
    def load_dialect_impl(self, dialect: Any) -> TypeEngine[Any]: ...
    def __getattr__(self, key: Any) -> Any: ...
    def process_literal_param(self, value: Optional[_T], dialect: Any) -> str: ...
    def process_bind_param(self, value: Optional[_T], dialect: Any) -> Any: ...
    def process_result_value(self, value: Any, dialect: Any) -> Optional[_T]: ...
    def literal_processor(self, dialect: Any) -> Callable[[Optional[_T]], str]: ...
    def bind_processor(self, dialect: Any) -> Callable[[Optional[_T]], Optional[Any]]: ...
    def result_processor(self, dialect: Any, coltype: Any) -> Callable[[Optional[Any]], Optional[_T]]: ...
    def bind_expression(self, bindparam: Any) -> Any: ...
    def column_expression(self, column: Any) -> Any: ...
    def coerce_compared_value(self, op: Any, value: Any) -> Any: ...
    def copy(self: _TD, **kw: Any) -> _TD: ...
    def get_dbapi_type(self, dbapi: Any) -> Any: ...
    def compare_values(self, x: Any, y: Any) -> bool: ...
    @property
    def sort_key_function(self) -> Optional[_SortKeyFunction]: ...  # type: ignore[override]

class Variant(TypeDecorator[_T]):
    impl: TypeEngine[Any] = ...
    mapping: Mapping[str, TypeEngine[Any]] = ...
    def __init__(self, base: Any, mapping: Mapping[str, TypeEngine[Any]]) -> None: ...
    def coerce_compared_value(self: _VT, operator: Any, value: Any) -> Union[_VT, TypeEngine[Any]]: ...
    def load_dialect_impl(self, dialect: Any) -> TypeEngine[Any]: ...
    def with_variant(self, type_: Type[TypeEngine[_U]], dialect_name: str) -> Variant[_U]: ...
    @property
    def comparator_factory(self) -> Type[Any]: ...  # type: ignore[override]

def to_instance(typeobj: Any, *arg: Any, **kw: Any): ...
def adapt_type(typeobj: Any, colspecs: Any): ...
